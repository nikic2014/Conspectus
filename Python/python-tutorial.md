# Учебник по Python

## Оглавление
1. [Введение в python]()
1. [Что такое backend]()
2. [Postger SQL]()
3. [Самое необходимое об ООП]()
4. [Energy Management]()
5. [Проект 1: калькулятор денег и калорий]()
6. [Django]()
7. [Дополнительные компоненты Django]()
8. [Тестирование]()
9. [Инфраструктура бэкенд-разработки]()
10. [Docker: приложение в коробке]()
11. [Оптимизация и мониторинг docker-образов. DockerHub]()
12. [Полезные ресурсы](##end)

## Введение в python 

Python — интерпретируемый язык программирования с сильной динамической типизацией. 

Сильная — значит, что язык не допускает неявных приведений типов в неоднозначных ситуациях или когда будет утрачена точность, например, нельзя “сложить” число и строку.

Динамическая — значит, что тип переменной определяется во время присваивания ей значения и может изменяться по ходу программы.

### Типы данных в python 

None: пустое значение.

Числа: 
1. int
2. float
3. complex

**Строки и операции над ними: string**

Срез:

    Общий вид среза s[x : y : h], где: 
    * x - номер элемента, с которого начинается срез,
    * y - номер первого элемента, невошедшего в срез,
    * h - шаг среза.    

len(s) - длина строки.

s.split() - разделяет строку по символу разделителя

Проверки внутри строк:
* s.isalpha() - состоит ли строка из букв;
* s.isalnum() - состоит ли строка из цифр и букв;
* s.islower() - состоит ли строка из букв в нижнем регистре;
* s.isupper() - состоит ли строка из букв в верхнем регистре;
* s.isspace() - состоит ли строка из пробельных символов;
* s.istitle() - начинаются ли слова в строке с заглавной буквы.

* s.startswith(...) - начинается ли строка s с указанного шалона;
* s.endswith(...) - заканчивается ли строка шаблоном.

**f строки**

Начиная с версии 3.6 в Python появился новый тип строк - f-строки. Эти строки предназначены для подстановки значений выражений непосредственно в строку. Подстановки обозначаются фигурными скобками {}, внутри которых записывается переменная или выражение, результат вычисления которого должен быть встроен в строку, а также дополнительная информация об отображении, например, число знаков после десятичной точки. f-строки улучшают читаемость кода, а также работают быстрее чем другие способы форматирования. Они задаются с помощью литерала «f» перед кавычками.

~~~
name = 'Bob'
print(f'Hello, {name}!')
~~~


**Кортежи: tuple**

По аналогии со списками кортежи в Python — это стандартный тип, позволяющий хранить значения в виде последовательности. Они полезны в тех случаях, когда необходимо передать данные, не позволяя изменять их. Эти данные могут быть использованы, но в оригинальной структуре изменения не отобразятся. Также картежи весят меньше чем списки.

Также все элементы уникальны.

Кортежи создают с помощью круглых скобок (). Для создания нужно написать следующее:

~~~
cake = ('c','a','k','e') 
print(type(cake))


a = (5) не кортеж
a = (5, ) кортеж
~~~



**Списки: list**

Список - упорядоченная изменяемая коллекция объектов произвольных типов (list).

~~~
a = [1, '2', 3.4]

b = list() создание пустого списка или 
b = []
~~~

* append(x) - функция используется, чтобы добавить элемент в список.

* insert(index, x) - вставляет в нужную позицию требуемое значение.

* pop() - удаляет последний элемент(можно передать индекс и будет аналогично remove).

* remove(index) - удаляет элемент по индексу.

К элементам можно обращаться и заменять по индексу.

К спискам можно применять срезы:

~~~
a = [1, 3, 8, 7]
a[START:STOP:STEP]
~~~

**Словари: dict**

Словарь dict - это ноль или более пар вида key: value, где key - это объект типа данных, таких как float, frozenset, int, str и tuple. value может быть объектом любог типа. Объявляется словарь фигурными скобками.

~~~
Добавление пары ключ-значение в словарь

d = {}
d['name'] = 'Anna'
d['age'] = 26
print(d)

out: {'name': 'Anna', 'age': 26}

Проверка наличия ключа в словаре

'name' in d

Общий вид этого метода get: 

dict.get(key[, default]) 

где key - это искомый ключ, а default - это значение, которое возвращает метод, если данный ключ не найден.
~~~

Методы для работы со словарем:
* len(dict) - количество пар "ключ-значение" в словаре
* del key - удаляет клюя вместе со значением из словаря
* dict.key() - возвращает список ключей словаря
* dict.values() - возвращает список значений словаря
* dict.items() - возвращает список кортежей (key, value)
* dict.clear() - очищает словарь

**Множества: set и frozenset**

Тип set – это неупорядоченная коллекция из нуля или более ссылок на объекты.

Все встроенные неизменяемые типы данных, такие как float, frozenset, int, str и tuple, являются хешируемыми объектами и могут добавляться во множества. Встроенные изменяемые типы данных, такие как dict, list и set, не являются хешируемыми объектами, так как значение хеша в каждом конкретном случае зависит от содержащихся в объекте элементов, поэтому они не могут добавляться в множества.

Множества объявляются через фигурные скобки, как и словари. Отличие заключается в том, что элемент станет множеством, если не будет ни одной пары ключ значение.

~~~
a = {a, b, c, d}
~~~

Методы множеств:
1. Добавление и удаление:
    * s.add(x) - добавляет элементы x во множество s, если они отсутствуют в s;
    * s.update(t) - добавляет во множество s все элементы множества t, отсутствующие в множестве s, аналогично s |= t (update есть и у словарей, о которых мы поговорим чуть позже).
    * s.discard(x) - удаляет элемент x из множества s, если он * присутствует в множестве s;
    * s.pop() - возвращает и удаляет случайный элемент множества s или возбуждает исключение KeyError, если s – это пустое множество;
    * s.remove(x) - удаляет элемент x из множества s или возбуждает исключение KeyError, если элемент x отсутствует в множестве s, аналогично set.discard();
    * s.clear() - удаляет все элементы из множества s;
    * s.copy() - возвращает поверхностную копию множества s.
2. Специфичные для множеств методы:
    * s.difference(t) - возвращает новое множество, включающее элементы множества s, которые отсутствуют в множестве t, аналогично s - t;
    * s.difference_update(t) - удаляет из множества s все элементы, присутствующие в множестве t, аналогично s -= t;
    * s.intersection(t) - возвращает новое множество, включающее элементы, присутствующие одновременно в множествах s и t, аналогично s & t;
    * s.intersection_update(t) - оставляет во множестве s пересечение множеств s и t, аналогично s &= t;
    * s.isdisjoint(t) - возвращает True, если множества s и t не имеют общих элементов;
    * s.issubset(t) или s <= t - возвращает True, если множество s эквивалентно множеству t или является его подмножеством; чтобы проверить, является ли множество s только подмножеством множества t, следует использовать проверку s < t;
    * s.issuperset(t) или s >= t - возвращает True, если множество s эквивалентно множеству t или является его над множеством; чтобы проверить, является ли множество s только над множеством множества t, следует использовать проверку s > t;
    * s.symmetric_difference(t) - возвращает новое множество, включающее все элементы, присутствующие в множествах s и t, за исключением элементов, присутствующих в обоих множествах одновременно, аналогично s ^ t;
    * s.symmetric_difference_update(t) - возвращает в множестве s результат строгой дизъюнкции множеств s и t, аналогично s ^= t;
    * s.union(t) - возвращает новое множество, включающее все элементы множества s и все элементы множества t, отсутствующие в множестве s, аналогично s | t;

Единственное отличие set от frozenset заключается в том, что set - изменяемый тип данных, а frozenset - нет.


### Арифметические операции в python

* \+ — сложение
* \- — вычитание
* \* — умножение (строку можно умножить на число)
* / — деление
* // — целочисленное деление (возвращает только целую часть от деления,  значение после запятой отбрасывается)
* % — деление по модулю (возвращает остаток от деления)
* ** — возведение в степень

**Битовые операторы**

* & – побитовое и
* | – побитовое или 
* ^ – xor
* << >> – операторы сдвига влево или сдвига вправо на заданное количество бит
* ~ – битовый оператор НЕТ 

### Основные алгоритмические конструкции

**Ветвление**

~~~
if <условие 1>:
    <операторы, если условие 1 истинно>
elif <условие 2>:
    <операторы, если условие 2 истинно>
elif <условие 3>:
    ...
else:
    <операторы, если все условия ложны>
~~~

**Тернарный оператор**

~~~
[если истина] if [выражение] else [если ложь]
~~~

Пример:

~~~
x, y = 25, 50
big = x if x < y else y
~~~

**Итерационный цикл**

~~~
while <условие>:
    <тело цикла, в котором есть break>
else:
    <операторы, если цикл завершился без break>
~~~

**Арифметический цикл**
~~~
for <проход по итератору>:
    <тело цикла>
~~~

Пример:

~~~
for i in range (1, 6, 1):
    print(i)

for i in 'aasdasd':
    print(i)
~~~



### Параметры функции print()

print(value, sep=' ', end='\n')

sep - разделитель между символами

end - что выводится после функции print

В качестве разделителей и окончания строки могут использоваться как обычные символы, так и экранированные последовательсности. Наиболее полезными будут следующие символы:

* \n - перевод строки
* \r - возврат каретки
* \b - забой, backspase
* \t - горизонтальная табуляция


# Полезные ресурсы 

Литература: 

1. [Марк Лутц «Изучаем Python»](http://uchcom7.botik.ru/L/prog/python/python_01.pdf)

2. [Стандарт написания кода на Python pep8](https://pythonworld.ru/osnovy/pep-8-rukovodstvo-po-napisaniyu-koda-na-python.html)

3. [Туториал по Django](https://tutorial.djangogirls.org/ru/)

4. [Кодкамп](https://www.codecamp.ru/tag/pythontuts/)

Ресурсы:

1. [Пример linter для python (проверяет корректность написания кода)](https://www.pythonchecker.com/)

2. [Сайт со всевозможными модулями](https://pypi.org/)

3. [Песочница для запуска кода](https://replit.com/languages/python3)

4. [Песочница для работы с гитом](https://learngitbranching.js.org/?locale=ru_RU)

5. [Бесплатные курсы (курс по Django)](https://itproger.com/course/django)


## end <a name="introduction"></a>